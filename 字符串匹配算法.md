# 字符串匹配算法

## BF算法 （brute force 暴力匹配算法)

在主串中，检查起始位置分别是 0、1、2…n-m 且长度为 m 的 n-m+1 个子串，看有没有跟模式串匹配的;**时间复杂度是O(n*m)**；

## RK 算法（BF 算法的升级版）

对BF算法稍加改造，引入哈希算法，时间复杂度立刻就会降低；
比如要处理的字符串只包含 a～z 这 26 个小写字母，那我们就用二十六进制来表示一个字符串。我们把 a～z 这 26 个字符映射到 0～25 这 26 个数字，a 就表示 0，b 就表示 1，以此类推，z 表示 25。我们通过哈希算法对主串中的 n-m+1 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小；
在十进制的表示法中，一个数字的值是通过下面的方式计算出来的。对应到二十六进制，一个包含 a 到 z 这 26 个字符的字符串，**计算哈希的时候，我们只需要把进位从 10 改成 26 就可以**。
![26jinzhi](/image/26进制.jpg)

这种哈希算法有一个特点，在主串中，相邻两个子串的哈希值的计算公式有一定关系；
相邻两个子串 s[i-1]和 s[i]（i 表示子串在主串中的起始位置，子串的长度都为 m），对应的哈希值计算公式有交集，也就是说，我们可以使用 s[i-1]的哈希值很快的计算出 s[i]的哈希值。如果用公式表示的话，就是下面这个样子：
![overlapString](/image/overlapString.jpg)

*还有个细节可以注意* 26^(m-1) 这部分的计算，我们可以通过查表的方法来提高效率（即事先计算好 26^0、26^1、26^2……26^(m-1)，并且存储在一个长度为 m 的数组中，公式中的“次方”就对应数组的下标）
**时间复杂度就是O(n)**



