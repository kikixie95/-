# note

#### 定义上下左右四个行走方向
   int[][] direction = {{-1, 0}, {0, -1}, {0, 1}, {1, 0}};

## 整体思路
使用深度优先搜索（DFS）和回溯的思想实现。关于判断元素是否使用过，用一个二维数组visited 对使用过的元素做标记。

### 外层：遍历
首先遍历 board 的所有元素，先找到和 word 第一个字母相同的元素，然后进入递归流程。假设这个元素的坐标为 (i, j)，进入递归流程前，先记得把该元素打上使用过的标记：

visited[i][j] = true
### 内层：递归
好了，打完标记了，现在我们进入了递归流程。递归流程主要做了这么几件事：

从 (i, j) 出发，朝它的上下左右试探，看看它周边的这四个元素是否能匹配 word 的下一个字母
如果匹配到了：带着该元素继续进入下一个递归
如果都匹配不到：返回 False
当 word 的所有字母都完成匹配后，整个流程返回 True
几个注意点
递归时元素的坐标是否超过边界，这里也可以自己写一个isArea的函数进行判断
回溯标记 visited[i][j] = false 以及 return 的时机（当start == word.length()-1)
